name: Update cars snapshot

on:
  schedule:
    - cron: '15 5 * * *'   # daily 05:15 UTC
  workflow_dispatch:

jobs:
  update:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - uses: actions/checkout@v4

      - name: Fetch cars JSON (fresh, with retries)
        run: |
          set -euo pipefail
          URL="https://vehicle-api-espm.onrender.com/cars?per_page=150000&page=1&_t=${{ github.run_id }}"
          echo "Downloading: $URL"
          rm -f cars_raw.json cars.json

          curl -sSLo cars_raw.json -H 'Cache-Control: no-cache' --retry 4 --retry-delay 4 --compressed "$URL" || {
            echo "::error ::curl failed; response (first 2k):"
            head -c 2000 cars_raw.json || true
            exit 1
          }

          # Basic sanity: must start with { (your /cars returns an object wrapper)
          if ! head -c 1 cars_raw.json | grep -q '^{'; then
            echo "::error ::cars_raw.json does not start with {"
            head -c 500 cars_raw.json || true
            exit 1
          fi

          echo "cars_raw.json OK ($(wc -c < cars_raw.json) bytes)"

          # Warn if we're likely truncating (exactly PER_PAGE results means "might be more")
          count="$(jq '.cars | length' cars_raw.json 2>/dev/null || echo 0)"
          echo "cars_raw.json cars count: $count"
          if [ "$count" -eq 150000 ]; then
            echo "::warning ::Snapshot returned exactly 150000 cars. You may be truncating (need pagination when ready)."
          fi

      - name: Normalize snapshot (extract cars[] + add legacy aliases)
        run: |
          set -euo pipefail

          # Build a flat array and add legacy/short keys used by the embeds.
          # We KEEP all original keys, and add aliases alongside them.
          jq -c '
            (.cars // [])
            | map(
                . as $c
                | $c
                + {
                    # legacy aliases your embeds log/use
                    lat: ($c.latitude // $c.lat),
                    lng: ($c.longitude // $c.lng),
                    price: ($c.price_gbp // $c.price),
                    mileage: ($c.mileage_mi // $c.mileage),
                    fuel: ($c.fuel_type // $c.fuel),
                    gearbox: ($c.transmission // $c.gearbox),
                    bodytype: ($c.body_type // $c.bodytype),
                    dealer: ($c.dealer_name // $c.dealer),
                    url: ($c.listing_url // $c.url),
                    thumb: ($c.image_cover_url // $c.thumb),

                    owners: ($c.num_owners // $c.owners),
                    reg: ($c.vehicle_registration_mark // $c.reg),
                    maxspeed_mph: ($c.performance_maxspeed_mph // $c.maxspeed_mph),
                    zero_to_60_mph: ($c.performance_acceleration_zero_to_60_mph // $c.zero_to_60_mph),
                    combined_mpg: ($c.efficiency_combined_mpg // $c.combined_mpg),

                    engine: ($c.engine_size_l // $c.engine),
                    power: ($c.power_ps // $c.power),
                    euro: ($c.euro_standard // $c.euro),
                    colour: ($c.color // $c.colour),

                    # HARD DEFAULTS so keys always exist (prevents random workflow aborts)
                    images_count: ($c.images_count // 0),
                    options: ($c.options // []),
                    features: ($c.features // []),
                    seller_comments: ($c.seller_comments // "")
                  }
             )
             ' cars_raw.json > cars.json

          # Quick sanity: ensure we produced an array and it has at least 1 element
          if ! head -c 1 cars.json | grep -q '^\['; then
            echo "::error ::cars.json is not an array after normalization"
            head -c 500 cars.json || true
            exit 1
          fi

          n="$(jq 'length' cars.json)"
          echo "Normalized cars.json length: $n"
          if [ "$n" -lt 1 ]; then
            echo "::error ::cars.json has no cars"
            exit 1
          fi

      - name: Required keys sanity (on normalized cars.json)
        run: |
          set -euo pipefail

          # Check first item has expected keys (normalized aliases included)
          REQUIRED_KEYS=(
            "lat"
            "lng"
            "price"
            "thumb"
            "url"
            "reg"
            "maxspeed_mph"
            "zero_to_60_mph"
            "combined_mpg"
            "images_count"
            "options"
            "features"
            "seller_comments"
          )

          missing=0
          for k in "${REQUIRED_KEYS[@]}"; do
            if ! jq -e ".[0] | has(\"$k\")" cars.json >/dev/null; then
              echo "::warning ::Missing key in cars.json[0]: $k"
              missing=$((missing+1))
            fi
          done

          if [ "$missing" -gt 0 ]; then
            echo "::error ::cars.json is missing $missing required keys. Aborting so you notice."
            jq '.[0]' cars.json || true
            exit 1
          fi

          echo "cars.json OK ($(wc -c < cars.json) bytes)"

      - name: Commit if changed
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "Daily snapshot"
          file_pattern: cars.json
