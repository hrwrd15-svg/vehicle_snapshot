name: Update cars snapshot

on:
  schedule:
    - cron: '15 5 * * *'   # daily 05:15 UTC
  workflow_dispatch:

jobs:
  update:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - uses: actions/checkout@v4

      - name: Fetch cars JSON (paged + lite + no-meta + backoff)
        run: |
          set -euo pipefail

          BASE="https://vehicle-api-espm.onrender.com/cars"
          PER_PAGE=20000        # safe for 512MB Render
          MAX_PAGES=30          # 20k * 30 = 600k cap
          T="${{ github.run_id }}"

          rm -f cars_raw.json cars.json page_*.json

          echo '{"cars":[]}' > cars_raw.json

          fetch_page () {
            local url="$1"
            local out="$2"

            local attempt=1
            while [ "$attempt" -le 8 ]; do
              local code
              code="$(
                curl -sSLo "$out" \
                  -H 'Cache-Control: no-cache' \
                  -H 'Accept: application/json' \
                  --compressed \
                  --connect-timeout 20 \
                  --max-time 240 \
                  -w "%{http_code}" \
                  "$url" || true
              )"

              if [ "$code" = "200" ]; then
                return 0
              fi

              # Transient gateway/service errors: back off and retry
              if [ "$code" = "503" ] || [ "$code" = "502" ] || [ "$code" = "504" ]; then
                echo "::warning ::HTTP $code (attempt $attempt/8). Backing off..."
                case "$attempt" in
                  1) sleep 5 ;;
                  2) sleep 10 ;;
                  3) sleep 20 ;;
                  4) sleep 30 ;;
                  5) sleep 45 ;;
                  6) sleep 60 ;;
                  7) sleep 90 ;;
                  8) sleep 120 ;;
                esac
                attempt=$((attempt+1))
                continue
              fi

              # Non-transient: fail and show body preview
              echo "::error ::HTTP $code from API"
              echo "::error ::Response (first 2000 chars):"
              head -c 2000 "$out" || true
              return 1
            done

            echo "::error ::API kept returning 502/503/504 after multiple retries."
            echo "::error ::Last response (first 2000 chars):"
            head -c 2000 "$out" || true
            return 1
          }

          page=1
          while [ "$page" -le "$MAX_PAGES" ]; do
            URL="${BASE}?lite=1&include_meta=0&per_page=${PER_PAGE}&page=${page}&_t=${T}"
            OUT="page_${page}.json"
            echo "Downloading page ${page}: $URL"

            fetch_page "$URL" "$OUT"

            # Validate JSON (donâ€™t assume first char)
            if ! jq -e '.' "$OUT" >/dev/null 2>&1; then
              echo "::error ::Page ${page} is not valid JSON"
              echo "::error ::Response (first 2000 chars):"
              head -c 2000 "$OUT" || true
              exit 1
            fi

            # Validate wrapper
            if ! jq -e 'has("cars") and (.cars | type=="array")' "$OUT" >/dev/null; then
              echo "::error ::Page ${page} JSON does not have expected { cars: [] } wrapper"
              echo "::error ::Top-level keys:"
              jq -r 'keys | join(", ")' "$OUT" || true
              exit 1
            fi

            count="$(jq '.cars | length' "$OUT")"
            echo "Page ${page} cars: ${count}"

            # Merge into cars_raw.json wrapper
            jq -s '.[0].cars += .[1].cars | .[0]' cars_raw.json "$OUT" > cars_raw_merged.json
            mv cars_raw_merged.json cars_raw.json

            # Be nice to the API between pages
            sleep 2

            # Stop at last page
            if [ "$count" -lt "$PER_PAGE" ]; then
              break
            fi

            page=$((page+1))
          done

          total="$(jq '.cars | length' cars_raw.json)"
          echo "cars_raw.json total cars: $total"
          echo "cars_raw.json OK ($(wc -c < cars_raw.json) bytes)"

          if [ "$total" -lt 1 ]; then
            echo "::error ::cars_raw.json has no cars"
            exit 1
          fi

      - name: Normalize snapshot (extract cars[] + add legacy aliases + defaults)
        run: |
          set -euo pipefail

          jq -c '
            (.cars // [])
            | map(
                . as $c
                | $c
                + {
                    # legacy aliases your embeds log/use
                    lat: ($c.latitude // $c.lat),
                    lng: ($c.longitude // $c.lng),
                    price: ($c.price_gbp // $c.price),
                    mileage: ($c.mileage_mi // $c.mileage),
                    fuel: ($c.fuel_type // $c.fuel),
                    gearbox: ($c.transmission // $c.gearbox),
                    bodytype: ($c.body_type // $c.bodytype),
                    dealer: ($c.dealer_name // $c.dealer),
                    url: ($c.listing_url // $c.url),
                    thumb: ($c.image_cover_url // $c.thumb),

                    # performance/efficiency aliases
                    owners: ($c.num_owners // $c.owners),
                    reg: ($c.vehicle_registration_mark // $c.reg),
                    maxspeed_mph: ($c.performance_maxspeed_mph // $c.maxspeed_mph),
                    zero_to_60_mph: ($c.performance_acceleration_zero_to_60_mph // $c.zero_to_60_mph),
                    combined_mpg: ($c.efficiency_combined_mpg // $c.combined_mpg),

                    # shorter names if UI expects them
                    engine: ($c.engine_size_l // $c.engine),
                    power: ($c.power_ps // $c.power),
                    euro: ($c.euro_standard // $c.euro),
                    colour: ($c.color // $c.colour),

                    # defaults so keys always exist (keeps your sanity check stable)
                    images_count: ($c.images_count // 0),
                    options: ($c.options // []),
                    features: ($c.features // []),
                    seller_comments: ($c.seller_comments // "")
                  }
              )
          ' cars_raw.json > cars.json

          # Quick sanity: ensure we produced an array and it has at least 1 element
          if ! jq -e 'type=="array" and length>0' cars.json >/dev/null; then
            echo "::error ::cars.json is not a non-empty array after normalization"
            head -c 500 cars.json || true
            exit 1
          fi

          n="$(jq 'length' cars.json)"
          echo "Normalized cars.json length: $n"
          echo "cars.json OK ($(wc -c < cars.json) bytes)"

      - name: Required keys sanity (sample first 50 cars)
        run: |
          set -euo pipefail

          REQUIRED_KEYS=(
            "lat" "lng" "price" "thumb" "url" "reg"
            "maxspeed_mph" "zero_to_60_mph" "combined_mpg"
            "images_count" "options" "features" "seller_comments"
          )

          missing=0
          for k in "${REQUIRED_KEYS[@]}"; do
            if ! jq -e ".[0:50] | all(has(\"$k\"))" cars.json >/dev/null; then
              echo "::warning ::Some of the first 50 cars are missing key: $k"
              missing=$((missing+1))
            fi
          done

          if [ "$missing" -gt 0 ]; then
            echo "::error ::cars.json missing $missing required keys (in first 50). Aborting."
            echo "::error ::Example first car:"
            jq '.[0]' cars.json || true
            exit 1
          fi

          echo "cars.json required-keys sanity OK"

      - name: Commit if changed
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "Daily snapshot"
          file_pattern: cars.json
